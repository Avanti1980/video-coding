{"./":{"url":"./","title":"简介","keywords":"","body":"　　该项目旨在记录自己压制过的视频：https://avanti1980.gitee.io/video-coding/ 　　考虑到arch下的安装、配置和更新，压制工具必然选VapourSynth，另外插件也很丰富，免去了到处找插件的烦恼： $ yay vapoursynth 196 aur/vapoursynth-plugin-neo_fft3dfilter-git r5.1.gabb9cdc-1 (+0 0.00) Plugin for Vapoursynth: neo_fft3dfilter (GIT version) 195 aur/vapoursynth-plugin-placebo-git r49.a8be164-1 (+0 0.00) Plugin for VapourSynth: placebo (GIT version) 194 aur/vapoursynth-tools-acsuite-git 4.1.1.r1.g808820a-1 (+0 0.00) Frame-based cutting/trimming/splicing of audio with VapourSynth (GIT version) 193 aur/vapoursynth-plugin-f3kdb 2.0.0-1 (+0 0.00) (孤立) flash3kyuu deband plugin for VapourSynth 192 aur/vapoursynth-plugin-waifu2x-ncnn-vulkan-git r3.0.g870f3c9-1 (+0 0.00) (已安装) Plugin for Vapoursynth: waifu2x-ncnn-vulkan (GIT version) …… 5 community/vapoursynth-plugin-lsmashsource 20200531-1 (61.8 KiB 141.9 KiB) L-SMASH source plugin for Vapoursynth 4 community/vapoursynth-plugin-fluxsmooth 2-2 (9.0 KiB 21.0 KiB) (已安装) FluxSmooth plugin for VapourSynth 3 community/vapoursynth-plugin-deblock 6-2 (10.1 KiB 17.8 KiB) Deblock plugin for VapourSynth 2 community/vapoursynth R50-1 (836.3 KiB 2.6 MiB) (已安装) A video processing framework with the future in mind 1 community/ffms2 2.23.1-3 (92.4 KiB 305.0 KiB) (已安装) A libav/ffmpeg based source library and Avisynth plugin for easy frame accurate access ==> 要安装的包 (示例: 1 2 3, 1-3 或 ^4) ==> 　　我个人安装的插件是 $ pacman -Q | grep vapoursynth vapoursynth R50-1 vapoursynth-editor-git r19.1.g4490d06-1 vapoursynth-plugin-addgrain-git r8.0.g75782b6-1 vapoursynth-plugin-adjust-git v1.0.g7370577-2 vapoursynth-plugin-awarpsharp2-git v4.0.g886d4b7-1 vapoursynth-plugin-bilateral-git r3.6.g5c246c0-1 vapoursynth-plugin-bm3d-git r8.0.g7b3d8dd-1 vapoursynth-plugin-ctmf-git r5.0.g073eccd-1 vapoursynth-plugin-d2vsource-git v1.2.0.g4535f7c-1 vapoursynth-plugin-dctfilter-git r2.1.1.g3c9cbea-1 vapoursynth-plugin-deblock-git r6.1.1.g02e2cec-1 vapoursynth-plugin-delogo-git v0.4.0.g597ad7f-1 vapoursynth-plugin-dfttest-git r7.0.gb228588-1 vapoursynth-plugin-eedi2-git r7.1.1.g36be83a-1 vapoursynth-plugin-eedi3cl-git r4.7.gd11bdb3-1 vapoursynth-plugin-f3kdb-git 2.0pre.r423.54ff2b0-1 vapoursynth-plugin-fft3dfilter-git R1.5.g8562ea7-1 vapoursynth-plugin-fluxsmooth 2-2 vapoursynth-plugin-fmtconv-git r22.7.g4f187bf-1 vapoursynth-plugin-havsfunc-git r33.2.g33719fc-1 vapoursynth-plugin-hqdn3d-git r10.eb820cb-1 vapoursynth-plugin-knlmeanscl-git 1.1.1.r552.1ba48ce-1 vapoursynth-plugin-lsmashsource-git r1046.b6aef0c-1 vapoursynth-plugin-mvsfunc-git v9.r50.7948c8b-1 vapoursynth-plugin-mvtools-git v23.0.g6d805e2-1 vapoursynth-plugin-nnedi3-git v12.0.g8c35822-1 vapoursynth-plugin-nnedi3_resample-git 13.0983895-3 vapoursynth-plugin-nnedi3_weights_bin r1-1 vapoursynth-plugin-nnedi3cl-git r8.0.geb2a810-1 vapoursynth-plugin-sangnom-git r41.10.g788bc2d-1 vapoursynth-plugin-svpflow1 4.2.0.142-2 vapoursynth-plugin-svpflow2-bin 4.3.0.168-1 vapoursynth-plugin-waifu2x-ncnn-vulkan-git r3.0.g870f3c9-1 vapoursynth-plugin-waifu2x-w2xc-git r8.3.ga9f064a-1 vapoursynth-plugin-yadifmod-git r10.1.1.g2b45ada-1 vapoursynth-plugin-znedi3-git r2.0.g78e5e67-1 　　下面是vpy脚本模板 #!/bin/env python ## coding: utf-8 import vapoursynth as vs import sys import havsfunc as haf # 扩展脚本 import mvsfunc as mvf # 扩展脚本 core = vs.get_core() # 对于mp4/mkv/m2ts文件 推荐用lsmash clip = core.lsmas.LWLibavSource(source=r'*.mp4', format='yuv420p16') # 对于ts文件 推荐用D2VWitch通过命令“D2VWitch file”生成索引文件 类似于avs里的dgIndex clip = core.d2v.Source(input=r'*.d2v', threads=1) # 切片段 clip = core.std.Trim(clip, first=21793, last=27805) # 删除台标 只能用于8位精度 clip = core.delogo.EraseLogo(clip, r'*.lgd') # 转成16位精度 clip = core.fmtc.bitdepth(clip, bits=16) # 加自己的图片logo [logo, alpha] = core.imwri.Read(filename='*.png', alpha=True) logo = core.resize.Bicubic(clip=logo, format=clip.format.id, matrix_s='709') alpha = core.fmtc.bitdepth(clip=alpha, bits=clip.format.bits_per_sample, fulld=True) clip = haf.Overlay(clipa=clip, clipb=logo, mask=alpha, x=**, y=-**) # 修改帧率 clip = haf.ChangeFPS(clip, 30, 1) # 反交错滤镜yadif和QTGMC二选一 # yadif依赖nnedi3 nnedi3的field参数设置： # 0 / 1: 保持帧率 底场优先(BFF) / 顶场优先(TFF) # 2 / 3: 双倍帧率 底场优先(BFF) / 顶场优先(TFF) # yadif的order参数设置为 0 / 1：BFF / TFF # yadif的field参数设置为 -1 / 0 / 1：与order相同 / BFF / TFF # yadif的mode参数设置为 # 0 / 2：保持帧率 (做 / 不做) 空间检测 # 1 / 3：双倍帧率 (做 / 不做) 空间检测 # 原视频是TFF还是BFF可以通过MediaInfo来查看 常见的是TFF居多 故用下面这行就行了 clip = core.yadifmod.Yadifmod(clip, core.nnedi3.nnedi3(clip, field=1, opt=2), order=1, field=-1, mode=0) # QTGMC依赖havsfunc、mvsfunc、adjust、znedi3、EEDI3、mvtools、fmtconv、temporalsoften 因此这些都配置好才能用 # 参数Preset控制质量 越慢越好 参数FPSDivisor=2表示帧率不翻倍 clip = haf.QTGMC(clip, Preset='Placebo', FPSDivisor=2, TFF=True) # 反胶卷过带 http://www.vapoursynth.com/doc/plugins/vivtc.html yv12 = core.resize.Bicubic(clip, format='yuv420p8') clip = core.vivtc.VFM(clip=yv12, order=1, clip2=clip) clip = core.vivtc.VDecimate(clip) # 切边 clip = core.std.CropRel(clip, left=10, right=10, top=10, bottom=10) # 改变尺寸 推荐Bicubic clip = core.resize.Bicubic(clip, 960, 540, filter_param_a=0.333, filter_param_b=0.333) # 放大&降噪 waifu2x 很慢 clip = mvf.ToRGB(clip, depth=32) clip = core.w2xc.Waifu2x(clip, noise=1, scale=2, block=128, photo=True, gpu=1) clip = mvf.ToYUV(clip, css=\"420\", depth=16) # 降噪 KNLMeansCL和BM3D二选一 推荐用前者 后者实在太慢了 clip = core.knlm.KNLMeansCL(clip, d=1, a=2, s=4, device_type=\"gpu\") clip = mvf.BM3D(clip, sigma=[3,3,3], radius1=1) # 字幕 clip = core.sub.TextFile(clip, file=r'*.ass') clip.set_output() 　　脚本写好后就可以通过vspipe喂给编码器了，h264编码任务可以通过如下命令行实现： vspipe **.vpy - --y4m | x264 --demuxer y4m - --preset slower --crf 20 --tune film --keyint 250 --min-keyint 1 --input-depth 16 --sar 1:1 -o a.264 - h265编码任务可以通过如下命令行实现： vspipe **.vpy - --y4m | x265 --y4m --preset slower --deblock -1:-1 --ctu 32 --qg-size 8 --crf 15.0 --pbratio 1.2 --cbqpoffs -2 --crqpoffs -2 --no-sao --me 3 --subme 5 --merange 38 --b-intra --limit-tu 4 --no-amp --ref 4 --weightb --keyint 360 --min-keyint 1 --bframes 6 --aq-mode 1 --aq-strength 0.8 --rd 5 --psy-rd 2.0 --psy-rdoq 1.0 --rdoq-level 2 --no-open-gop --rc-lookahead 80 --scenecut 40 --qcomp 0.65 --no-strong-intra-smoothing --input-depth 16 --output-depth 10 --sar 1:1 -o a.hevc - Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-03 11:36:54 "},"Scarlet/download-rename.html":{"url":"Scarlet/download-rename.html","title":"下载 & 重命名","keywords":"","body":"　　查询网盘现有的ts文件： $ baidupcs ls /绯红/晨间原档等多个文件 | sed -n 's/.*ＮＨＫ\\(.*\\)ts.*/ＮＨＫ\\1ts/p' ＮＨＫＢＳプレミアム 連続テレビ小説 スカーレット（３９）「弟子にしてください！」[解][字] 20191113_0730.ts ＮＨＫＢＳプレミアム 連続テレビ小説 スカーレット（４０）「弟子にしてください！」[解][字] 20191114_0730.ts 这个例子中网盘存放着第39和40集。 　　查询本地下载的ts文件： $ ls ~/Videos/绯红/原档 190920 もうすぐ！連続テレビ小説「スカーレット」.ts 190927 いよいよスタート！連続テレビ小説「スカーレット」スペシャル_Cut.ts 190930-ep1.ts 191001-ep2.ts …… 191112-ep38.ts 191113-ep39.ts 注意本地文件进行了重命名，这是为了避免日文给后续压制带来麻烦。 　　下载没有下过的ts文件，脚本如下： #!/usr/bin/env bash SAVEIFS=$IFS IFS=$(echo -en \"\\n\\b\") # 查询网盘现有的ts文件 download_list=($(baidupcs ls /绯红/晨间原档等多个文件 | sed -n 's/.*ＮＨＫ\\(.*\\)ts.*/ＮＨＫ\\1ts/p')) # 查询本地下载的ts文件 exist_files=$(ls ~/Videos/绯红/原档) for line in ${download_list[@]}; do # 依次处理网盘中现有的ts文件 # 获取日期 time=$(echo $line | sed -n 's/.*].20\\(.*\\)_.*/\\1/p') # 获取集数并处理日文数字 ep=$(echo $line | sed 's/.*（\\([１２３４５６７８９０]*\\)）.*/\\1/g') ep=${ep//０/0} ep=${ep//１/1} ep=${ep//２/2} ep=${ep//３/3} ep=${ep//４/4} ep=${ep//５/5} ep=${ep//６/6} ep=${ep//７/7} ep=${ep//８/8} ep=${ep//９/9} # 是否已经下到本地了? if [[ \"$exist_files\" =~ \"$time-ep$ep.ts\" ]]; then echo 文件 \"\" 已存在 else line=${line// /\\\\ } # 空格要加斜杠转义 # 是否下到本地了但还没有重命名？ if [[ \"$exist_files\" =~ \"$line\" ]]; then echo 文件 \"$line\" 已存在 else echo 文件 \"$line\" 不存在 开始下载 baidupcs download -saveto ~/Videos/绯红/原档/ /绯红/晨间原档等多个文件/$line fi # 中括号要加斜杠转义 line=${line//[/\\\\[} line=${line//]/\\\\]} # 将本地的ts文件重命名 mv ~/Videos/绯红/原档/$line ~/Videos/绯红/原档/$time-ep$ep.ts fi done Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-03 11:36:54 "},"Scarlet/encoding-upload.html":{"url":"Scarlet/encoding-upload.html","title":"压制 & 上传","keywords":"","body":"　　晨间剧洋洋洒洒150+集，每集的压制流程又非常雷同，所以必然批量处理以节约时间。具体到绯红，每集需分成4个部分分别处理，然后再将其连接起来： op之前的部分，无需做特别处理 op中的动画部分，这部分视频的原始帧率是12fps，为了能够在30fps的电视上播放，先倍帧到24fps然后做胶卷过带，所以压制时要将这个过程逆回去，先做反胶卷过带，然后砍掉一半重复帧 toda单人对着镜头微笑的特写是24fps转30fps的，需做反胶卷过带 op之后的部分，无需做特别处理 　　为了方便多次压制，先将各个部分的起始帧数保存在tasklist.txt中： $ cat tasklist.txt # 190930-ep1,971,4605,7134,7303,27944,小档剪前后档多余内容 # 191001-ep2,978,2764,4829,4922,27951 # …… # 191011-ep11,986,1536,3601,3694,27960 # 191012-ep12,987,1864,3929,4022,27960,lsmash # 191012-ep12,980,1857,3922,4015,27953,d2vwitch # 191012-ep12,971,1848,3913,4006,27944,ffms2 # …… # 191016-ep15,989,1617,3682,3775,27962 # 191017-ep16,999,2683,4748,4841,27972,从本集开始小档不剪前后档多余内容 # 191018-ep17,1007,1744,3809,3902,27980 # …… # 191123-ep48,989,2541,4606,4699,27962 第1个数字不是零是因为还录了一小部分前档节目，第5个数字是后档节目的起始帧数。 　　压制的vpy脚本如下： ##!/bin/env python ## coding: utf-8 import vapoursynth as vs import havsfunc as haf core = vs.get_core() # 读取文件 clip = core.lsmas.LWLibavSource(source=r'原档/19****-ep*.ts') # 剪掉多录的前后档节目 具体数据从tasklist.txt中读取 每集都不一样 clip = core.std.Trim(clip, first=971, last=27943) # 去NHKBS台标 clip = core.delogo.EraseLogo(clip, r'logo/NHKBSP2019 1920x1080.lgd') clip = core.fmtc.bitdepth(clip, bits=16) # 加字幕组logo [logo, alpha] = core.imwri.Read(filename='logo/logo.png', alpha=True) logo = core.resize.Bicubic(clip=logo, format=clip.format.id, matrix_s='709') alpha = core.fmtc.bitdepth(clip=alpha, bits=clip.format.bits_per_sample, fulld=True) clip = haf.Overlay(clipa=clip, clipb=logo, mask=alpha, x=1400, y=-460) # 降噪 clip = core.knlm.KNLMeansCL(clip, d=1, a=2, s=4, device_type='gpu') # 添加字幕 clip = core.sub.TextFile(clip, file=r'压制字幕/19****-ep*.ass') # 第一部分无需特别处理 clip1 = core.std.Trim(clip, first=971-971, last=4604-971) # 第二部分先反胶卷过带 再砍掉一半帧 clip2 = core.std.Trim(clip, first=4605-971, last=7133-971) clip2 = core.vivtc.VFM(core.resize.Bicubic(clip2, format=vs.YUV420P8), order=1, clip2=clip2) clip2 = core.vivtc.VDecimate(clip2) clip2 = haf.ChangeFPS(clip2, 12000, 1001) # 第三部分反胶卷过带 clip3 = core.std.Trim(clip, first=7134-971, last=7302-971) clip3 = core.vivtc.VFM(core.resize.Bicubic(clip3, format=vs.YUV420P8), order=1, clip2=clip3) clip3 = core.vivtc.VDecimate(clip3) # 第四部分无需特别处理 clip4 = core.std.Trim(clip, first=7303-971, last=27943-971) # 当前要压制哪一部分 就输出哪一部分 clip*.set_output() 　　最终shell脚本如下： #!/usr/bin/env bash SAVEIFS=$IFS IFS=$(echo -en \"\\n\\b\") # 读取网盘熟肉文件夹名中的更新集数 total_ep=$(baidupcs ls /绯红 | sed -n 's/.*第\\(.*\\)集.*/\\1/p') # 读取网盘熟肉文件夹中的实际文件总数 和total_ep可能会不一样 total_file=$(baidupcs ls /绯红/绯红【更新至第$total_ep集】 | sed -n 's/.*文件总数: \\(.*\\),.*/\\1/p') echo 当前网盘中共有$total_file集 while read -r line; do # 根据tasklist.txt进行压制 line=${line// /} # 去掉空格 # 如果含有#号或整行为空则跳过 否则进行压制 换言之想压制哪一集就将前面的#号去掉即可 if [[ \"$line\" =~ \"#\" ]] || [ -z \"$line\" ]; then continue else # 获取当前压制的文件名 比如190930-ep1 filename=$(echo $line | cut -d ',' -f 1) # 获取集数 ep=$(echo $filename | cut -d 'p' -f 2) # 补零到三位数 因为晨间总共150+集 if [[ $ep -lt 10 ]]; then ep=00$ep elif [[ $ep -lt 100 ]]; then ep=0$ep fi echo ******开始处理ep$ep****** # 获取每个部分的起始帧数和结束帧数 clip1_start=$(echo $line | cut -d ',' -f 2) clip2_start=$(echo $line | cut -d ',' -f 3) clip3_start=$(echo $line | cut -d ',' -f 4) clip4_start=$(echo $line | cut -d ',' -f 5) clip5_start=$(echo $line | cut -d ',' -f 6) clip1_end=$(($clip2_start - 1)) clip2_end=$(($clip3_start - 1)) clip3_end=$(($clip4_start - 1)) clip4_end=$(($clip5_start - 1)) # 第一部分的起始帧数也是整集的起始帧数 换算成的格式 sec=$(($clip1_start * 1001 / 30000)) msec=$(($clip1_start * 1001 % 30000)) msec=$(($msec / 3)) min=$(($sec / 60)) sec=$(($sec % 60)) hour=$(($min / 60)) min=$(($min % 60)) clip_start=$hour:$min:$sec.$msec # 第四部分的结束帧数也是整集的结束帧数 换算成的格式 sec=$(($clip4_end * 1001 / 30000)) msec=$(($clip4_end * 1001 % 30000)) msec=$(($msec / 3)) min=$(($sec / 60)) sec=$(($sec % 60)) hour=$(($min / 60)) min=$(($min % 60)) clip_end=$hour:$min:$sec.$msec # 将音频剪出来 ffmpeg -nostdin -hide_banner -loglevel panic -i 原档/$filename.ts -ss $clip_start -to $clip_end -vn -c copy $filename.aac # 写vpy脚本 echo \"##!/bin/env python\" >encoder.vpy echo \"## coding: utf-8\" >>encoder.vpy echo \"import vapoursynth as vs\" >>encoder.vpy echo \"import havsfunc as haf\" >>encoder.vpy echo \"core = vs.get_core()\" >>encoder.vpy echo \"clip = core.lsmas.LWLibavSource(source=r'原档/$filename.ts')\" >>encoder.vpy # echo \"clip = core.ffms2.Source(source=r'原档/$filename.ts')\" >>encoder.vpy if [ \"$ep\" -le 15 ] || [ \"$ep\" -ge 40 ]; then # 1-15和40-的字幕是针对剪了前后节目的小档的 echo \"clip = core.std.Trim(clip, first=$clip1_start, last=$clip4_end)\" >>encoder.vpy fi echo \"clip = core.delogo.EraseLogo(clip, r'logo/NHKBSP2019 1920x1080.lgd')\" >>encoder.vpy echo \"clip = core.fmtc.bitdepth(clip, bits=16)\" >>encoder.vpy echo \"[logo, alpha] = core.imwri.Read(filename='logo/logo.png', alpha=True)\" >>encoder.vpy echo \"logo = core.resize.Bicubic(clip=logo, format=clip.format.id, matrix_s='709')\" >>encoder.vpy echo \"alpha = core.fmtc.bitdepth(clip=alpha, bits=clip.format.bits_per_sample, fulld=True)\" >>encoder.vpy echo \"clip = haf.Overlay(clipa=clip, clipb=logo, mask=alpha, x=1400, y=-460)\" >>encoder.vpy echo \"clip = core.knlm.KNLMeansCL(clip, d=1, a=2, s=4, device_type='gpu')\" >>encoder.vpy echo \"clip = core.sub.TextFile(clip, file=r'字幕/$filename.ass')\" >>encoder.vpy if [ \"$ep\" -le 15 ] || [ \"$ep\" -ge 40 ]; then # 1-15和40-的字幕是针对剪了前后节目的小档的 echo \"clip1 = core.std.Trim(clip, first=$clip1_start-$clip1_start, last=$clip1_end-$clip1_start)\" >>encoder.vpy echo \"clip2 = core.std.Trim(clip, first=$clip2_start-$clip1_start, last=$clip2_end-$clip1_start)\" >>encoder.vpy echo \"clip2 = core.vivtc.VFM(core.resize.Bicubic(clip2, format=vs.YUV420P8), order=1, clip2=clip2)\" >>encoder.vpy echo \"clip2 = core.vivtc.VDecimate(clip2)\" >>encoder.vpy echo \"clip2 = haf.ChangeFPS(clip2, 12000, 1001)\" >>encoder.vpy echo \"clip3 = core.std.Trim(clip, first=$clip3_start-$clip1_start, last=$clip3_end-$clip1_start)\" >>encoder.vpy echo \"clip3 = core.vivtc.VFM(core.resize.Bicubic(clip3, format=vs.YUV420P8), order=1, clip2=clip3)\" >>encoder.vpy echo \"clip3 = core.vivtc.VDecimate(clip3)\" >>encoder.vpy echo \"clip4 = core.std.Trim(clip, first=$clip4_start-$clip1_start, last=$clip4_end-$clip1_start)\" >>encoder.vpy else echo \"clip1 = core.std.Trim(clip, first=$clip1_start, last=$clip1_end)\" >>encoder.vpy echo \"clip2 = core.std.Trim(clip, first=$clip2_start, last=$clip2_end)\" >>encoder.vpy echo \"clip2 = core.vivtc.VFM(core.resize.Bicubic(clip2, format=vs.YUV420P8), order=1, clip2=clip2)\" >>encoder.vpy echo \"clip2 = core.vivtc.VDecimate(clip2)\" >>encoder.vpy echo \"clip2 = haf.ChangeFPS(clip2, 12000, 1001)\" >>encoder.vpy echo \"clip3 = core.std.Trim(clip, first=$clip3_start, last=$clip3_end)\" >>encoder.vpy echo \"clip3 = core.vivtc.VFM(core.resize.Bicubic(clip3, format=vs.YUV420P8), order=1, clip2=clip3)\" >>encoder.vpy echo \"clip3 = core.vivtc.VDecimate(clip3)\" >>encoder.vpy echo \"clip4 = core.std.Trim(clip, first=$clip4_start, last=$clip4_end)\" >>encoder.vpy fi echo \"clip1.set_output()\" >>encoder.vpy # 压制第一部分 vspipe encoder.vpy - --y4m | x264 --demuxer y4m --crf 23.0 --preset slow --tune film --keyint 600 --min-keyint 1 --input-depth 16 -o clip1.264 - # 压制第二部分 注意先修改vpy脚本的最后一行 sed -i '$d' encoder.vpy echo \"clip2.set_output()\" >>encoder.vpy vspipe encoder.vpy - --y4m | x264 --demuxer y4m --crf 23.0 --preset slow --tune film --keyint 600 --min-keyint 1 --input-depth 16 -o clip2.264 - # 压制第三部分 注意先修改vpy脚本的最后一行 sed -i '$d' encoder.vpy echo \"clip3.set_output()\" >>encoder.vpy vspipe encoder.vpy - --y4m | x264 --demuxer y4m --crf 23.0 --preset slow --tune film --keyint 600 --min-keyint 1 --input-depth 16 -o clip3.264 - # 压制第四部分 注意先修改vpy脚本的最后一行 sed -i '$d' encoder.vpy echo \"clip4.set_output()\" >>encoder.vpy vspipe encoder.vpy - --y4m | x264 --demuxer y4m --crf 23.0 --preset slow --tune film --keyint 600 --min-keyint 1 --input-depth 16 -o clip4.264 - # 若本地已有熟肉则删除 这种情况发生在重新压制 if [ -f \"熟肉/【绯红联合字幕组】Scarlet.Ep$ep.1080p.mp4\" ]; then rm \"熟肉/【绯红联合字幕组】Scarlet.Ep$ep.1080p.mp4\" fi # 合并所有的.264和.aac得到最终的熟肉 echo \"file 'clip1.264'\" >filelist.txt echo \"file 'clip2.264'\" >>filelist.txt echo \"file 'clip3.264'\" >>filelist.txt echo \"file 'clip4.264'\" >>filelist.txt ffmpeg -nostdin -hide_banner -loglevel panic -f concat -i filelist.txt -i $filename.aac -c copy 熟肉/【绯红联合字幕组】Scarlet.Ep$ep.1080p.mp4 rm 原档/*lwi *.264 filelist.txt encoder.vpy $filename.aac # 删除压制的中间文件 # 若网盘熟肉文件夹已有熟肉则删除 这种情况发生在重新压制 if [ -n \"$(baidupcs ls /绯红/绯红【更新至第$total_ep集】 | grep Ep$ep)\" ]; then echo 网盘中已有ep$ep 将其删除 baidupcs rm /绯红/绯红【更新至第$total_ep集】/【绯红联合字幕组】Scarlet.Ep$ep.1080p.mp4 fi # 上传熟肉 baidupcs upload ~/Videos/绯红/熟肉/【绯红联合字幕组】Scarlet.Ep$ep.1080p.mp4 /绯红/绯红【更新至第$total_ep集】/ fi done Copyright © Avanti 2020 all right reserved，powered by Gitbook文件最后修改时间： 2021-06-03 11:36:54 "}}